# 浏览器渲染引擎（RenderingEngine）
#### 浏览器渲染引擎是由各大浏览器厂商依照 W3C 标准自行研发的，也被称之为`「浏览器内核」`
#### 目前，市面上使用的主流浏览器内核有5类：Trident、Gecko、Presto、Webkit、Blink。
* **Trident：** 俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器有 IE11 -，以及各种国产多核浏览器中的IE兼容模块。另外微软的 Edge 浏览器不再使用 MSHTML 引擎，而是使用类全新的引擎 EdgeHTML
* **Gecko：** 俗称 Firefox 内核，Netscape6 开始采用的内核，后来的 Mozilla FireFox（火狐浏览器）也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因
* **Presto：** Opera 前内核，为啥说是前内核呢？因为 Opera12.17 以后便拥抱了 Google Chrome 的 Blink 内核，此内核就没了寄托
* **Webkit：** Safari 内核，也是 Chrome 内核原型，主要是 Safari 浏览器在使用的内核，也是特性上表现较好的浏览器内核。也被大量使用在移动端浏览器上
* **Blink：**  由 Google 和 Opera Software 开发，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。Blink 其实是  **Webkit** 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink
## 渲染引擎的工作流程
浏览器渲染引擎最重要的工作就是将 HTML 和 CSS 文档解析组合最终渲染到浏览器窗口上。如下图所示，渲染引擎在接受到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -> 构建渲染树 -> 渲染树布局 -> 渲染树绘制

![](https://user-gold-cdn.xitu.io/2017/11/1/6555b409fcdee45a07b5362d93e879ff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

* 解析 HTML 构建 DOM 树
* 构建渲染树
* 渲染树布局
* 渲染树绘制

解析 HTML 构建 DOM 树时渲染引擎会将 HTML 文件的便签元素解析成多个 DOM 元素对象节点，并且将这些节点根据父子关系组成一个树结构。同时 CSS 文件被解析成 CSS 规则表，然后将每条 CSS 规则按照「从右向左」的方式在 DOM 树上进行逆向匹配，生成一个具有样式规则描述的 DOM 渲染树。接下来就是将渲染树进行布局、绘制的过程。首先根据 DOM 渲染树上的样式规则，对 DOM 元素进行**大小和位置**的定位，关键属性如position; width; margin; padding; top; border;...，接下来再根据元素样式规则中的color; background; shadow; ...规则进行绘制。  

另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是**解析完一部分内容就显示一部分内容**，同时，可能还在通过网络下载其余内容。  

再者，需要注意的是，在浏览器渲染完首屏页面后，如果对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制，我们叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，**重绘发生时未必会触发渲染引擎的重排，但是如果发生了重排就必然会触发重绘**操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循**「避免重排；减少重绘」**的原则。    

## 不同浏览器内核间的差异
在不同的浏览器内核下， 浏览器页面渲染的流程略有不同  

![](https://user-gold-cdn.xitu.io/2017/11/1/93d153abe60bf7fd8dd8461827d79887?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  

#### Webkit 内核下，HTML 和 CSS 文件的解析是同步的  
#### Geoko 内核下，CSS 文件需要等到 HTML 文件解析成内容 Sink 后才进行解析  
另外描述术语也有不同，除此之外两者的流程就基本相同了，其中最重要的三个部分就是 **「HTML 的解析」「CSS 的解析」「渲染树的生成」**。这三个部分的原理比较深，会涉及到「词法分析」「语法分析」「转换」「解释」等数据结构的知识

## 关于 CSS 规则的匹配
上面我们提到过， CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配的，最终生成一个具有样式规则描述的 DOM 渲染树。  

但是你知道为什么要「从右向左」做逆向匹配吗？  

我们重新回看【webkit 内核工作流程图】  

![](https://user-gold-cdn.xitu.io/2017/11/1/1bc8d128e62937cc42a55290e99783d8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  

## 相关的性能优化
我们大致可以在以上案例中看到同浏览器渲染引擎相关的可行优化点  

大致为以下几种  

### 减少 JS 加载对 Dom 渲染的影响

将 JS 文件放在 HTML 文档后加载，或者使用异步的方式加载 JS 代码

### 避免重排，减少重绘

在做 css 动画的时候减少使用 width、 margin、 padding 等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替。另外值得注意的是，在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排

### 减少使用关系型样式表的写法

直接使用唯一的类名即可最大限度的提升渲染效率，另外尽量避免在选择器末尾添加通配符

### 减少 DOM 的层级

减少无意义的 dom 层级可以减少 渲染引擎 Attachment 过程中的匹配计算量


